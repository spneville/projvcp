  program projection

    implicit none

    integer*4                               :: iarg
    integer*8, parameter                    :: maxdim=60
    integer*8                               :: ncoo,nmodes,ngroup
    integer*8, dimension(maxdim)            :: iimag,npatm
    integer*8, dimension(maxdim,maxdim)     :: patm
    real*8, dimension(maxdim)               :: peig,mass,xcoo
    real*8, dimension(maxdim,maxdim)        :: hess,pmat,phess,pvec
    character(len=80)                       :: ain,atmp,amass,ahess
    character(len=2), dimension(maxdim)     :: aatm
    character(len=6)                        :: pntgrp
    character(len=6), dimension(3)          :: axirrep
    character(len=6), dimension(maxdim)     :: qirrep

!------------------------------------------------------------------
! Read input file name
!------------------------------------------------------------------
    ain=''
    call getarg(1,ain)
    if (ain.eq.'') then
       write(6,'(/,a,/)') 'Filename not specified!'
       STOP
    endif

!------------------------------------------------------------------
! Read input file
!------------------------------------------------------------------
    call rdinp(ain,ahess,mass,maxdim,patm,npatm,xcoo,aatm,ncoo,&
         pntgrp,axirrep,ngroup)

!------------------------------------------------------------------
! Read the Hessian from the input file
!------------------------------------------------------------------
    call rdhess(ahess,hess,maxdim,ncoo,nmodes)

!------------------------------------------------------------------
! Mass-weight the Hessian
!------------------------------------------------------------------
    call massweight(mass,ncoo,hess,maxdim)

!------------------------------------------------------------------
! Calculate the sum of projected Hessians
!------------------------------------------------------------------
    call calcphess(phess,maxdim,ngroup,hess,pmat,ncoo,patm,npatm,&
         mass,xcoo)

!------------------------------------------------------------------
! Diagonalise the sum of projected Hessians
!------------------------------------------------------------------
    call diagphess(ncoo,phess,maxdim,pvec,peig,iimag)

!------------------------------------------------------------------
! Normalise the eigenvectors of the sum of projected Hessians
!------------------------------------------------------------------
    call normalise(pvec,ncoo,maxdim)

!------------------------------------------------------------------
! Calculate the frequencies of the translational and rotational
! DOFs for each group of atoms
!------------------------------------------------------------------
    if (ngroup.gt.1) call rtfreq(maxdim,ngroup,hess,pmat,ncoo,&
         patm,npatm,mass,xcoo,peig,pvec)

!------------------------------------------------------------------
! Similarity transform the Hessian using the eigenvectors of the
! sum of projected Hessians
!------------------------------------------------------------------
    call simtrans(hess,maxdim,pvec,ncoo)

!------------------------------------------------------------------
! Rotate everything to the Eckart frame
!------------------------------------------------------------------
    call eckart(xcoo,pvec,mass,maxdim,ncoo)

!------------------------------------------------------------------
! Determine the irreps generated by the 'projected normal modes'
!------------------------------------------------------------------
    call getirreps(pntgrp,axirrep,pvec,maxdim,ncoo,qirrep)

!------------------------------------------------------------------
! Output the eigenvectors of the sum of projected Hessians
!------------------------------------------------------------------
    call wrout(pvec,maxdim,ncoo,peig,iimag,xcoo,aatm,ain,qirrep)

    STOP

    contains

!##################################################################

    subroutine rdinp(ain,ahess,mass,maxdim,patm,npatm,xcoo,aatm,&
         ncoo,pntgrp,axirrep,ngroup)

      use iomod

      implicit none
      
      integer*8                                   :: iin,ic,iz,&
                                                     ierr,i,j,k,&
                                                     maxdim,&
                                                     ncoo,ngroup,itmp,&
                                                     jtmp
      integer*8, parameter                        :: maxkey=48,&
                                                     maxkeylen=200
      integer*8, dimension(maxkey)                :: lc      
      character(len=maxkeylen), dimension(maxkey) :: keyword,&
                                                     keyorig
      character(len=240)                          :: inptit


      integer*8, dimension(maxdim,maxdim)         :: patm
      integer*8, dimension(maxdim)                :: npatm
      real*8, dimension(maxdim)                   :: mass,xcoo
      real*8, dimension(3)                        :: xcom
      real*8                                      :: tmass
      character(len=80)                           :: ain,ahess
      character(len=2), dimension(maxdim)         :: aatm
      character(len=6)                            :: pntgrp,atmp
      character(len=6), dimension(3)              :: axirrep

!------------------------------------------------------------------
! Set defaults
!------------------------------------------------------------------
      ahess=''
      pntgrp=''
      do i=1,3
         axirrep(i)=''
      enddo

      npatm=0
      ngroup=0

      do i=1,maxdim
         mass(i)=0.0d0
         xcoo(i)=0.0d0
         aatm(i)=''
      enddo

!------------------------------------------------------------------
! Open input file
!------------------------------------------------------------------
      iin=20
      open(iin,file=ain,form='formatted',status='old')

!------------------------------------------------------------------
! Read keywords
!------------------------------------------------------------------
10    continue
      call rdinpf(iin,keyword,keyorig,inptit,lc,ic,iz,ierr,maxkey)
      
      i=1
15    continue
      if (keyword(i) .eq. 'end-input') then
         goto 20
         
      else if (keyword(i).eq.'hessian_file') then
         if (keyword(i+1).eq.'=') then
            i=i+2
            read(keyword(i),'(a)') ahess
         else
            write(6,'(/,a,/)') &
                 'No argument given with the hessian_file keyword'
            STOP
         endif

      else if (keyword(i).eq.'project') then
30       continue
      i=1
      call rdinpf(iin,keyword,keyorig,inptit,lc,ic,iz,ierr,&
           maxkey)         
      if (keyword(1).ne.'end-project') then
         ngroup=ngroup+1
         ! Read first atom number of the current group
         read(keyword(1),*) itmp
         patm(itmp,ngroup)=1
         npatm(ngroup)=1
         i=i+1
         if (keyword(i).eq.',') then
            if (keyword(i+1).eq.'..') then
               i=i+3
               read(keyword(i),*) jtmp
               do k=itmp+1,jtmp
                  patm(k,ngroup)=1
                  npatm(ngroup)=npatm(ngroup)+1
               enddo
            else
31             continue
               i=i+1
               read(keyword(i),*) jtmp
               patm(jtmp,ngroup)=1
               npatm(ngroup)=npatm(ngroup)+1
               if (keyword(i+1).eq.',') then
                  i=i+1
                  goto 31
               endif
            endif
         endif
         goto 30
      endif

      else if (keyword(i).eq.'geometry') then
         k=0
35       continue
         call rdinpf(iin,keyword,keyorig,inptit,lc,ic,iz,ierr,&
              maxkey)
         if (keyword(1).ne.'end-geometry') then
            k=k+1
            read(keyword(1),'(a)') aatm(k)
            read(keyword(2),*) xcoo(k*3-2)
            read(keyword(3),*) xcoo(k*3-1)
            read(keyword(4),*) xcoo(k*3)
            call uppercase(aatm(k),len(aatm(k)))
            if (aatm(k).eq.'N') then
               mass(k)=14.0067d0
            else if (aatm(k).eq.'C') then 
               mass(k)=12.0107d0
            else if (aatm(k).eq.'H') then    
               mass(k)=1.00794d0
            else
               write(6,'(/,2(a,x),/)') 'Unknown atom type:',aatm(k)
            endif
            goto 35
         endif
         ncoo=k*3

      else if (keyword(i).eq.'point_group') then
         if (keyword(i+1).eq.'=') then
            i=i+2
            read(keyword(i),'(a)') pntgrp
            call uppercase(pntgrp,len(pntgrp))
         else
            write(6,'(/,a,/)') &
                 'No argument given with the point_group keyword'
            STOP
         endif

      else if (keyword(i).eq.'axis_symmetry') then
40       continue
         call rdinpf(iin,keyword,keyorig,inptit,lc,ic,iz,ierr,&
              maxkey)
         if (keyword(1).ne.'end-axis_symmetry') then
            
            read(keyword(1),'(a)') atmp
            call uppercase(atmp,len(atmp))
           
            if (atmp.eq.'X') then
               k=1
            else if (atmp.eq.'Y') then
               k=2
            else if (atmp.eq.'Z') then
               k=3
            else
               write(6,'(/,2(a,2x),/)') 'Unknown axis label:',atmp
               STOP
            endif

            read(keyword(2),'(a)') axirrep(k)
            call uppercase(axirrep(k),len(axirrep(k)))

            goto 40
         endif

      else
         write(6,'(/,2(a,2x),/)') 'Unknown keyword:',keyword(i)
         STOP
      endif

!------------------------------------------------------------------
! Check if more keywords are to be read, else read new line
!------------------------------------------------------------------
      if (i.lt.ic) then
         i=i+1
         go to 15
      else
         go to 10
      endif

20    continue
      close(iin)

!------------------------------------------------------------------
! Check that all the required information has been given
!------------------------------------------------------------------
      if (pntgrp.eq.'') then
         write(6,'(/,a,/)') 'Point group not specified!'
         STOP
      endif

      do i=1,3
         if (axirrep(i).eq.'') then
            write(6,'(/,a,/)') &
                 'Not all axis irreps have been specified!'
            STOP
         endif
      enddo

!------------------------------------------------------------------
! Translate to the centre of mass
!------------------------------------------------------------------
      tmass=0.0d0
      do i=1,3
         xcom(i)=0.0d0
      enddo
      do i=1,ncoo/3
         tmass=tmass+mass(i)
        do j=1,3
            xcom(j)=xcom(j)+xcoo(i*3-3+j)*mass(i)
         enddo
      enddo
      do i=1,3
         xcom(i)=xcom(i)/tmass
      enddo
      do i=1,ncoo/3
         do j=1,3
            xcoo(i*3-3+j)=xcoo(i*3-3+j)-xcom(j)
         enddo
      enddo

      return
    end subroutine rdinp

!##################################################################

      subroutine uppercase(string,dim)

        implicit none

        integer*4          :: dim,j
        character(len=dim) :: string

        do j = 1,len(string)
           if(string(j:j).ge."a".and.string(j:j).le."z")&
                then
              string(j:j)=achar(iachar(string(j:j))-32)
           end if
        enddo

      return
    end subroutine uppercase

!##################################################################
    
    subroutine rdhess(ahess,hess,maxdim,ncoo,nmodes)

      implicit none

      integer*8                        :: unit,i,j,k,itmp,&
                                          maxdim,ncoo,nmodes,itype
      real*8, dimension(maxdim,maxdim) :: hess
      character(len=80)                :: ahess

! Open file
      unit=20
      open(unit,file=ahess,form='formatted',status='old')

! Determine the file type
      call getfiletype(unit,itype)

! Read the Hessian
      rewind(unit)
      if (itype.eq.1) then
         call rdaoforce(unit,hess,maxdim,ncoo,nmodes)
      else if (itype.eq.2) then
         call rdnumforce(unit,hess,maxdim,ncoo,nmodes)
      endif

! Close file
      close(unit)

! Check that maxdim is high enough
      if (ncoo.gt.maxdim) then
         write(6,'(/,a,/)') 'Re-dimension maxdim!'
         STOP
      endif

      return
    end subroutine rdhess

!##################################################################
!
! itype: 1 <--> Turbomole, aoforce
!        2 <--> Turbomole, numforce
!
!##################################################################

    subroutine getfiletype(unit,itype)

      implicit none
      
      integer*8         :: unit,itype
      character(len=90) :: string
      
      itype=0

10    continue
      read(unit,'(a)',end=999) string
      
      if (string(1:11).eq.'$nprhessian') then
         itype=1
      else if (string(1:8).eq.'$hessian'.and.&
           string(11:19).ne.'projected') then
         itype=2
      endif

      goto 10

999   continue

      if (itype.eq.0) then
         write(6,'(/,a,/)') 'Hessian file type not recognised'
         STOP
      endif

      return
    end subroutine getfiletype

!##################################################################
    
    subroutine rdaoforce(unit,hess,maxdim,ncoo,nmodes)

      implicit none
      
      integer*8                        :: unit,maxdim,curr,i,j,k,itmp,&
                                          ncoo,nmodes
      real*8, dimension(maxdim,maxdim) :: hess
      real*8, dimension(5)             :: ftmp
      character(len=90)                :: string

! Read to the non-projected Hessian section
10    continue
      read(unit,'(a)') string
      if (string(1:11).ne.'$nprhessian') goto 10

! Read the non-projected Hessian
      curr=1
20    continue
      read(unit,'(a)') string
      if (string(1:15).ne.'$nprvibrational') then

         read(string,'(i2,1x,i2,2x,5(F13.10,2x))') k,itmp,&
              (ftmp(i), i=1,5)

         if (k.gt.curr) curr=curr+1

         j=0
         do i=itmp*5-4,itmp*5
            j=j+1
            hess(i,curr)=ftmp(j)
         enddo

         goto 20

      endif

! Set the variable ncoo (no. Cartesian coords) and nmodes (no. 
! normal modes)
      ncoo=curr
      nmodes=ncoo-6

      return
    end subroutine rdaoforce

!##################################################################

    subroutine rdnumforce(unit,hess,maxdim,ncoo,nmodes)

      implicit none
      
      integer*8                        :: unit,maxdim,curr,i,j,k,l,itmp,&
                                          ncoo,nmodes,nline,count
      real*8                           :: f
      real*8, dimension(maxdim,maxdim) :: hess
      real*8, dimension(5)             :: ftmp
      character(len=90)                :: string

! Read to the non-projected Hessian section
      read(unit,*)

! Calculate no. lines per column
      f=ncoo/5.0d0
      nline=ceiling(f)

! Read the non-projected Hessian
      do i=1,ncoo
         do j=1,nline
            
            read(unit,'(7x,5(F13.10,2x))') (ftmp(k), k=1,5)

            count=0
            do l=j*5-4,j*5
               count=count+1
               hess(l,i)=ftmp(count)
            enddo

         enddo
      enddo
      
      return
    end subroutine rdnumforce

!##################################################################

    subroutine massweight(mass,ncoo,hess,maxdim)

      implicit none

      integer*8                        :: ncoo,maxdim,unit,i,j,k,l
      real*8, dimension(maxdim,maxdim) :: hess
      real*8, dimension(maxdim)        :: mass

! Mass-weight the Hessian
      do i=1,ncoo/3
         do j=1,ncoo/3
            do k=i*3-2,i*3
               do l=j*3-2,j*3
                      hess(k,l)=hess(k,l)/sqrt(mass(i)*mass(j))
               enddo
            enddo
         enddo
      enddo

      return
    end subroutine massweight

!##################################################################

    subroutine calcphess(phess,maxdim,ngroup,hess,pmat,ncoo,patm,npatm,&
         mass,xcoo)

      implicit none
 
      integer*8                               :: maxdim,ngroup,ncoo,i,m,n
      integer*8, dimension(maxdim,maxdim)     :: patm
      integer*8, dimension(maxdim)            :: npatm
      real*8, dimension(maxdim,maxdim)        :: phess
      real*8, dimension(maxdim,maxdim)        :: phessint
      real*8, dimension(maxdim,maxdim)        :: hess,pmat
      real*8, dimension(maxdim)               :: mass,xcoo

!------------------------------------------------------------------     
! Initialise arrays
!------------------------------------------------------------------
      phess=0.0d0

!------------------------------------------------------------------     
! For each group of atoms, construct the corresponding projector, 
! project the Hessian and add the resulting matrix to the sum of 
! projected Hessians
!------------------------------------------------------------------     
      ! Loop over groups
      do i=1,ngroup

         ! For the current group, construct the corresponding projector
         call makeproj(ncoo,patm,npatm,pmat,maxdim,mass,xcoo,i)

         ! Project the Hessian using the current projector
         call projhess(ncoo,phessint(1:maxdim,1:maxdim),maxdim,pmat,hess)

         ! Add the current projected Hessian to the sum of projected 
         ! Hessians
         do m=1,ncoo
            do n=1,ncoo
               phess(n,m)=phess(n,m)+phessint(n,m)
            enddo
         enddo

      enddo

      return
    end subroutine calcphess

!##################################################################

    subroutine makeproj(ncoo,patm,npatm,pmat,maxdim,mass,xcoo,curr)

      implicit none

      integer*8                           :: i,j,ncoo,maxdim,curr
      integer*8, dimension(maxdim)        :: npatm
      integer*8, dimension(maxdim,maxdim) :: patm
      real*8, dimension(maxdim,maxdim)    :: pmat
      real*8, dimension(maxdim)           :: mass,xcoo

!------------------------------------------------------------------
! Initialise the pmat array
!------------------------------------------------------------------
      pmat=0.0d0

!------------------------------------------------------------------
! 1.) Projection out of the DOFs of the atoms not in the current
!     group
!------------------------------------------------------------------
      do i=1,ncoo
         if (patm(i,curr).eq.1) then
            do j=i*3-2,i*3
               pmat(j,j)=1.0d0
            enddo
         endif
      enddo

!------------------------------------------------------------------
! 2.) Projection out of the translational and rotational DOFs of
!     the atoms of the current group
!------------------------------------------------------------------
      if (npatm(curr).gt.1) &
           call rtproj(pmat,patm,maxdim,mass,ncoo,npatm,xcoo,curr)

      return
    end subroutine makeproj

!##################################################################

    subroutine rtproj(pmat,patm,maxdim,mass,ncoo,npatm,xcoo,curr)

      implicit none

      integer*8                           :: maxdim,ncoo,i,j,k,l,curr
      integer*8, dimension(maxdim)        :: npatm
      integer*8, dimension(maxdim,maxdim) :: patm
      real*8, dimension(maxdim,maxdim)    :: pmat
      real*8, dimension(maxdim)           :: mass,xcoo
      real*8, dimension(6,ncoo)           :: vec
      real*8, dimension(6,6)              :: smat,invsmat
      real*8, dimension(ncoo,6)           :: bmat
      real*8, dimension(ncoo,ncoo)        :: rmat
      logical(kind=4)                     :: lcheck

      real*8, dimension(6)                :: work
      integer*4, dimension(6)             :: ipiv
      integer*4                           :: info

!------------------------------------------------------------------
! New approach: (i)  Construct six (non-orthogonal) vectors
!                    spanning the translation-rotation subspace;
!               (ii) Construct the contribution to the projector 
!                    by orthogonalising these vectors
!
! Procedure taken from J. Chem. Phys., 88, 922 (1988)
!------------------------------------------------------------------

!------------------------------------------------------------------
! Initialise arrays
!------------------------------------------------------------------
      vec=0.0d0

!------------------------------------------------------------------
! Vectors 1-3: translation along the three Cartesian axes
!------------------------------------------------------------------
      ! Loop over the translational DOFs
      do i=1,3
         ! Construct the vector for the current DOF
         do j=1,ncoo/3
            k=j*3-3+i
            vec(i,k)=sqrt(mass(j))
         enddo
      enddo

!------------------------------------------------------------------
! Vectors 4-6: infinitesimal displacements corresponding to
!              rotation about the three Cartesian axes
!------------------------------------------------------------------
      ! Rotation about the x-axis
      do i=1,ncoo/3
         j=i*3-1
         k=i*3
         vec(4,j)=sqrt(mass(i))*xcoo(k)
         vec(4,k)=-sqrt(mass(i))*xcoo(j)
      enddo

      ! Rotation about the y-axis
      do i=1,ncoo/3
         j=i*3-2
         k=i*3
         vec(5,j)=-sqrt(mass(i))*xcoo(k)
         vec(5,k)=sqrt(mass(i))*xcoo(j)
      enddo

      ! Rotation about the z-axis
      do i=1,ncoo/3
         j=i*3-2
         k=i*3-1
         vec(6,j)=sqrt(mass(i))*xcoo(k)
         vec(6,k)=-sqrt(mass(i))*xcoo(j)
      enddo

!------------------------------------------------------------------
! Remove contributions from atoms not in the current group
!------------------------------------------------------------------
      do i=1,ncoo/3
         if (patm(i,curr).ne.1) then
            do k=1,6
               do l=1,3
                  vec(k,i*3-3+l)=0.0d0
               enddo
            enddo
         endif
      enddo

!------------------------------------------------------------------
! Calculate the projector R onto the translational and rotational
! DOFs using R=b*S^-1*b^T, where S=vec^T*vec.
!
! Here, R <-> rmat, S <-> smat, b <-> bmat (matrix of vectors)
!------------------------------------------------------------------
      ! Construct the b-matrix
      bmat=0.0d0
      do i=1,6
         do j=1,ncoo
            bmat(j,i)=vec(i,j)
         enddo
      enddo

      ! Calculate the S-matrix
      smat=0.0d0
      do i=1,6
         do j=1,6
            do k=1,ncoo
               smat(i,j)=smat(i,j)+bmat(k,i)*bmat(k,j)
            enddo
         enddo
      enddo

      ! Invert the S-matrix
      invsmat=smat
      call dgetrf(6,6,invsmat,6,ipiv,info)
      if (info.ne.0) then
         write(6,'(/,a,/)') &
              "LU factorisation of the S-matrix failed"
         STOP
      endif
      call dgetri(6,invsmat,6,ipiv,work,6,info)
      if (info.ne.0) then
         write(6,'(/,a,/)') &
              "Diagonalisation of the S-matrix failed"
         STOP
      endif

      ! Calculate the projection matrix R <-> rmat
      rmat=0.0d0
      do i=1,ncoo
         do j=1,ncoo
            do k=1,6
               do l=1,6
                  rmat(i,j)=rmat(i,j)+&
                       bmat(i,k)*invsmat(k,l)*bmat(j,l)
               enddo
            enddo
         enddo
      enddo

!------------------------------------------------------------------
! Subtract the projector onto the translation-rotation subspace 
! (rmat) from the total projector (pmat)
!------------------------------------------------------------------
      do j=1,ncoo
         do k=1,ncoo
            pmat(j,k)=pmat(j,k)-rmat(j,k)
         enddo
      enddo

      return
    end subroutine rtproj

!##################################################################

    subroutine projhess(ncoo,phess,maxdim,pmat,hess)

      implicit none
      
      integer*8                        :: i,j,k,l,ncoo,maxdim
      real*8, dimension(maxdim,maxdim) :: phess,pmat,hess

!------------------------------------------------------------------     
! Initialise the phess array
!------------------------------------------------------------------     
      phess=0.0d0

!------------------------------------------------------------------     
! Project the Hessian
!------------------------------------------------------------------     
      do i=1,ncoo
         do j=1,ncoo
            do k=1,ncoo
               do l=1,ncoo
                  phess(i,j)=phess(i,j)+&
                       pmat(i,k)*hess(k,l)*pmat(l,j)
               enddo
            enddo
         enddo
      enddo

      return
    end subroutine projhess

!##################################################################

    subroutine diagphess(ncoo,phess,maxdim,pvec,peig,iimag)

      implicit none

      integer*8                        :: i,j,ncoo,maxdim,sign
      integer*4                        :: error,e2
      integer*8, dimension(maxdim)     :: iimag
      real*8, dimension(maxdim,maxdim) :: phess,pvec
      real*8, dimension(maxdim)        :: peig
      real*8, dimension(ncoo,ncoo)     :: tmp
      real*8, dimension(ncoo)          :: lambda
      real*8, dimension(3*ncoo)        :: work

! Copy the projected Hessian to a temporary array to be 
! diagonalised
      do i=1,ncoo
         do j=1,ncoo
            tmp(i,j)=phess(i,j)
         enddo
      enddo

! Diagonalise the projected Hessian
      e2=3*ncoo
      call dsyev('V','U',ncoo,tmp,ncoo,lambda,work,e2,error)

! Check to see if the diagonalisation was successful. If not, exit
! with the error code
      if (error.ne.0) then
          write(6,'(/,a,2/,a,x,i20,/)') &
               ' Diagonalisation of the projected Hessian failed.'&
               ,' dsyev error:',error
          STOP
       endif

! Save the eigenvectors and eigenvalues of the projected Hessian
      do i=1,ncoo
         ! Flag imaginary frequencies: for an imaginary frequency,
         ! take the absolute value of the corresponding eigenvalue
         ! and output the value of it's square root 'multiplied by
         ! i'
         iimag(i)=0
         if (lambda(i).lt.0) then
            sign=-1
            iimag(i)=1
         else
            sign=1
         endif
         ! Ensure the eigenvalue is positive
         peig(i)=lambda(i)*sign
         do j=1,ncoo
            pvec(i,j)=tmp(i,j)
         enddo
      enddo

      return
    end subroutine diagphess

!##################################################################

    subroutine normalise(pvec,ncoo,maxdim)

      implicit none
      
      integer*8                        :: ncoo,maxdim,i,j,k
      real*8, dimension(maxdim,maxdim) :: pvec
      real*8                           :: len

! Loop over the eigenvectors
      do i=1,ncoo
! Calculate the length of the current eigenvector
         len=0.0d0
         do j=1,ncoo
            len=len+pvec(j,i)*pvec(j,i)
         enddo
         len=sqrt(len)
! Normalise the current eigenvector
         do j=1,ncoo
            pvec(j,i)=pvec(j,i)/len
         enddo
      enddo

      return
    end subroutine normalise

!##################################################################

    subroutine eckart(xcoo,pvec,mass,maxdim,ncoo)

      implicit none

      integer*8                        :: maxdim,ncoo,i,j,k,l,m,n,&
                                          ilbl,jlbl
      real*8, dimension(maxdim)        :: xcoo,mass,tmp
      real*8, dimension(3)             :: xcom
      real*8                           :: tmass
      real*8, dimension(maxdim,maxdim) :: pvec,rotvec
      real*8, dimension(ncoo,ncoo)     :: tmat
      real*8, dimension(3,3)           :: itensor

      integer*4                        :: error,e2
      real*8, dimension(3)             :: ieig
      real*8, dimension(9)             :: work

!------------------------------------------------------------------
! Calculate the moment of inertia tensor
!------------------------------------------------------------------
      do i=1,3
         do j=1,3
            itensor(i,j)=0.0d0
         enddo
      enddo

      do i=1,ncoo/3
         itensor(1,1)=itensor(1,1)+mass(i)*(xcoo(i*3-1)**2+xcoo(i*3)**2)
         itensor(2,2)=itensor(2,2)+mass(i)*(xcoo(i*3-2)**2+xcoo(i*3)**2)
         itensor(3,3)=itensor(3,3)+mass(i)*(xcoo(i*3-2)**2+xcoo(i*3-1)**2)
         itensor(1,2)=itensor(1,2)-mass(i)*(xcoo(i*3-2)*xcoo(i*3-1))
         itensor(1,3)=itensor(1,3)-mass(i)*(xcoo(i*3-2)*xcoo(i*3))
         itensor(2,3)=itensor(2,3)-mass(i)*(xcoo(i*3-1)*xcoo(i*3))
      enddo
      itensor(2,1)=itensor(1,2)
      itensor(3,1)=itensor(1,3)
      itensor(3,2)=itensor(2,3)

!------------------------------------------------------------------
! Diagonalise the moment of inertia tensor
!------------------------------------------------------------------
      e2=9
      call dsyev('V','U',3,itensor,3,ieig,work,e2,error)
      
      if (error.ne.0) then
         write(6,'(/,a,2/,a,x,i20,/)') &
        ' Diagonalisation of the moment of inertia tensor failed.'&
        ,' dsyev error:',error
         STOP
      endif

!------------------------------------------------------------------
! Create the transformation matrix
!------------------------------------------------------------------
      do i=1,ncoo
         do j=1,ncoo
            tmat(i,j)=0.0d0
         enddo
      enddo

      do i=1,ncoo/3
         k=i*3-2
         ilbl=0
         do m=k,k+2
            ilbl=ilbl+1
            jlbl=0
            do n=k,k+2
               jlbl=jlbl+1
               tmat(m,n)=itensor(ilbl,jlbl)
            enddo
         enddo
      enddo

!------------------------------------------------------------------
! Rotate the coordinates using the eigenvectors of the moment of
! inertia tensor
!------------------------------------------------------------------
      do i=1,ncoo
         tmp(i)=0.0d0
         do j=1,ncoo
            tmp(i)=tmp(i)+tmat(i,j)*xcoo(j)
         enddo
      enddo

      do i=1,ncoo
         xcoo(i)=tmp(i)
      enddo
      
!------------------------------------------------------------------
! Rotate the eigenvectors of the projected Hessian using the 
! eigenvectors of the moment of inertia tensor
!------------------------------------------------------------------
      ! Loop over the eigenvectors
      do i=1,ncoo
         ! Rotate the current eigenvector
         do j=1,ncoo
            tmp(j)=0.0d0
            do k=1,ncoo
               tmp(j)=tmp(j)+tmat(j,k)*pvec(k,i)
            enddo
         enddo
         do j=1,ncoo
            pvec(j,i)=tmp(j)
         enddo
      enddo

      return
    end subroutine eckart

!##################################################################

    subroutine getirreps(pntgrp,axirrep,pvec,maxdim,ncoo,qirrep)

      implicit none

      integer*8                               :: maxdim,ncoo,order
      integer*8, dimension(maxdim,maxdim)     :: chi
      integer*8, dimension(maxdim)            :: nel
      real*8, dimension(maxdim,maxdim)        :: pvec
      character(len=6)                        :: pntgrp
      character(len=6), dimension(3)          :: axirrep
      character(len=6), dimension(maxdim)     :: airrep,qirrep

!------------------------------------------------------------------
! Get characters
!------------------------------------------------------------------
      call getcharacters(pntgrp,chi,maxdim,airrep,nel,order)

!------------------------------------------------------------------
! Determine the irreps generated by the eigenvectors by operating 
! on the eigenvectors using the projectors onto the irreps of the
! point group
!------------------------------------------------------------------
      call projectq(pvec,maxdim,ncoo,chi,axirrep,airrep,&
           nel,order,qirrep)

      return
    end subroutine getirreps

!##################################################################

    subroutine getcharacters(pntgrp,chi,maxdim,airrep,nel,order)

      implicit none
      
      integer*8                           :: maxdim,order
      integer*8, dimension(maxdim)        :: nel
      integer*8, dimension(maxdim,maxdim) :: chi
      character(len=6)                    :: pntgrp
      character(len=6), dimension(maxdim) :: airrep

      if (pntgrp.eq.'C1') then
         
         ! Irrep 1: A
         airrep(1)='A'
         chi(1,1)=1

         ! Numbers of elements in each class
         nel(1)=1

         ! Order of the group
         order=1

      else if (pntgrp.eq.'CS') then
         
         ! Irrep 1: A'
         airrep(1)='A'''
         chi(1,1)=1
         chi(1,2)=1

         ! Irrep 2: A''
         airrep(2)='A'''''
         chi(2,1)=1
         chi(2,2)=-1

         ! Numbers of elements in each class
         nel(1)=1
         nel(2)=1

         ! Order of the group
         order=2

      else if (pntgrp.eq.'C2V') then

         ! Irrep 1: A1
         airrep(1)='A1'
         chi(1,1)=1
         chi(1,2)=1
         chi(1,3)=1
         chi(1,4)=1

         ! Irrep 2: A2
         airrep(2)='A2'
         chi(2,1)=1
         chi(2,2)=1
         chi(2,3)=-1
         chi(2,4)=-1

         ! Irrep 3: B1
         airrep(3)='B1'
         chi(3,1)=1
         chi(3,2)=-1
         chi(3,3)=1
         chi(3,4)=-1

         ! Irrep 4: B2
         airrep(4)='B2'
         chi(4,1)=1
         chi(4,2)=-1
         chi(4,3)=-1
         chi(4,4)=1

         ! Numbers of elements in each class
         nel(1)=1
         nel(2)=1
         nel(3)=1
         nel(4)=1

         ! Order of the group
         order=4

      else
         write(6,'(/,2(a,2x),/)') 'Point group not supported:',&
              pntgrp
      endif

      return
    end subroutine getcharacters

!##################################################################

    subroutine projectq(pvec,maxdim,ncoo,chi,axirrep,&
         airrep,nel,order,qirrep)

      implicit none

      integer*8                               :: maxdim,ncoo,&
                                                 order,i,j,k,a,n,r
      integer*8, dimension(maxdim)            :: nel
      integer*8, dimension(maxdim,maxdim)     :: chi
      integer*8, dimension(maxdim,3)          :: fac
      real*8, dimension(maxdim,maxdim)        :: pvec
      real*8, dimension(maxdim,maxdim,maxdim) :: t1pvec
      real*8, dimension(maxdim,maxdim)        :: t2pvec
      real*8, parameter                       :: tol=0.01d0
      character(len=6), dimension(3)          :: axirrep
      character(len=6), dimension(maxdim)     :: airrep,qirrep
      logical(kind=4)                         :: lzero,lirrep

!------------------------------------------------------------------
! Set defaults
!------------------------------------------------------------------
      qirrep='N.A.'

!------------------------------------------------------------------
! Determine the characters of the representations of the operators
! generated by the x, y, and z basis vectors:
!
! fac(i,j) <-> character of the representation of the ith class 
!              of operators generated by the jth basis vector 
!              (j=1 <-> x, j=2 <-> y, j=3 <-> z)
!------------------------------------------------------------------
      ! Loop over classes
      do i=1,order
         ! Loop over x, y, and z basis vectors
         do j=1,3
            ! Determine which irrep is generated by the current
            ! basis vector
            do k=1,order
               if (axirrep(j).eq.airrep(k)) a=k
            enddo
            fac(i,j)=chi(a,i)
         enddo
      enddo

!------------------------------------------------------------------
! Transform the eigenvectors for each class of operators
!------------------------------------------------------------------
      ! Loop over classes
      do i=1,order
         ! Loop over eigenvectors
         do j=1,ncoo
            ! Transform each element of the eigenvector
            do k=1,ncoo/3
               t1pvec(i,k*3-2,j)=pvec(k*3-2,j)*fac(i,1)
               t1pvec(i,k*3-1,j)=pvec(k*3-1,j)*fac(i,2)
               t1pvec(i,k*3,j)=pvec(k*3,j)*fac(i,3)
            enddo
         enddo
      enddo

!------------------------------------------------------------------
! Form the projected eigenvectors and thus determine the irreps
! generated by the eigenvectors
!------------------------------------------------------------------
      ! Loop over the irreps and construct the projected 
      ! eigenvector for the current
      do r=1,order
         t2pvec=0.0d0
         ! Loop over the eigenvectors         
         do n=1,ncoo


            ! Transform the current eigenvector using the current
            ! operator:
            do i=1,order ! Loop over classes
               do k=1,ncoo ! Loop over the elements of the current eigenvector
                  t2pvec(k,n)=t2pvec(k,n)+t1pvec(i,k,n)*chi(r,i)*nel(i)
               enddo
            enddo


            ! Determine whether the current eigenvector generates
            ! the current irrep
            lzero=.true.

            print*,
            print*,r,n
            ! (1) Is the transformed vector zero?
            !     Yes => the vector generates another irrep.
            do k=1,ncoo
               if (abs(t2pvec(k,n)).gt.tol) lzero=.false.
               print*,t2pvec(k,n)
            enddo




            ! (2) If the transformed vector is non-zero, is it the original 
            !     vector multiplied by the order of the group?
            !     Yes => the vector generates the current irrep.
            !     No  => the vector doesn't generate an irrep (could be the
            !            case for one of the vectors spanning the
            !            translation-rotation subspace?)
            if (.not.lzero) then
               lirrep=.true.
               do k=1,ncoo
                  if (abs(t2pvec(k,n)-order*pvec(k,n)).gt.tol) &
                       lirrep=.false.
               enddo
               if (lirrep) qirrep(n)=airrep(r)
            endif

         enddo
      enddo

      return
    end subroutine projectq

!##################################################################

    subroutine rtfreq(maxdim,ngroup,hess,pmat,ncoo,patm,npatm,&
         mass,xcoo,peig,pvec)

      implicit none

      integer*8                           :: maxdim,ngroup,ncoo,i,j,k,l,&
                                             count
      integer*8, dimension(maxdim,maxdim) :: patm
      integer*8, dimension(maxdim)        :: tmpiimag,npatm
      real*8, dimension(maxdim,maxdim)    :: phessint
      real*8, dimension(maxdim,maxdim)    :: hess,pmat,tmpphess,tmppvec,&
                                             pvec,rtvec
      real*8, dimension(maxdim)           :: mass,xcoo,tmppeig,peig,rteig
      real*8, parameter                   :: tol=0.000001d0

      count=0

! Loop over groups
      do i=1,ngroup

         ! Skip if the current group consists of a single atom
         if (npatm(i).eq.1) cycle

!------------------------------------------------------------------
! Calculate the projector onto the translation-rotation subspace for
! the current group of atoms
!------------------------------------------------------------------
         pmat=0.0d0
         call rtproj(pmat,patm,maxdim,mass,ncoo,npatm,xcoo,i)
         pmat=-pmat

!------------------------------------------------------------------
! Project the Hessian onto the translation-rotation subspace for the
! current group of atoms
!------------------------------------------------------------------
         call projhess(ncoo,tmpphess,maxdim,pmat,hess)

!------------------------------------------------------------------
! Diagonalise the projected Hessian
!------------------------------------------------------------------
         call diagphess(ncoo,tmpphess,maxdim,tmppvec,tmppeig,tmpiimag)

!------------------------------------------------------------------
! Replace the vectors spanning the translation-rotation subspace
! in the pvec array by the current set of vectors
!------------------------------------------------------------------
         ! Copy the six translational/rotational vectors and
         ! corresponding eigenvalues to their own arrays
         k=0
         rteig=0.0d0
         rtvec=0.0d0
         do j=1,ncoo
            if (abs(tmppeig(j)).gt.tol) then
               k=k+1
               rteig(k)=tmppeig(j)
               do l=1,ncoo
                  rtvec(l,k)=tmppvec(l,j)
               enddo
            endif
         enddo

         ! Loop over the vectors stored in pvec and replace by one of the
         ! current set of vectors if the corresponding value of peig(n) is
         ! below the tolerance
         k=0
10       continue
         count=count+1
         if (abs(peig(count)).lt.tol) then
            k=k+1
            peig(count)=rteig(k)
            do j=1,ncoo
               pvec(j,count)=rtvec(j,k)
            enddo
         endif
         if (k.lt.6) goto 10

      enddo

      return
    end subroutine rtfreq

!##################################################################

    subroutine simtrans(hess,maxdim,pvec,ncoo)

      implicit none

      integer*8                        :: maxdim,ncoo,i,j,k,l,unit,itmp,jtmp
      real*8, dimension(maxdim,maxdim) :: hess,sthess
      real*8, dimension(maxdim,maxdim) :: pvec
      real*8                           :: ftmp

!------------------------------------------------------------------
! Similarity transform the mass-weighted Hessian using the 
! eigenvectors of the sum of projected Hessians
!------------------------------------------------------------------
      sthess=0.0d0
      ftmp=0.0d0
      do i=1,ncoo
         do j=1,ncoo
            do k=1,ncoo
               do l=1,ncoo
                  sthess(i,j)=sthess(i,j)+pvec(k,i)*hess(k,l)*pvec(l,j)
               enddo
            enddo
            if (i.ne.j.and.sthess(i,j)*27.2116.gt.ftmp) then
               ftmp=sthess(i,j)*27.2116
               itmp=i
               jtmp=j
            endif
         enddo
      enddo

!------------------------------------------------------------------
! Output the elements of the similarity transformed Hessian
!------------------------------------------------------------------
      ! Open file
      unit=20
      open(unit,file='sthess',form='formatted',status='unknown')

      ! Write to file
      write(unit,'(a,/,a,2x,2(i3,2x),/)') &
           'All energies in cm-1',&
           'Largest off-diagonal element:',itmp,jtmp
      do i=1,ncoo
         do j=i,ncoo
            write(unit,'(2x,i3,2x,i3,3x,F13.7)') i,j,&
                 sqrt(abs(sthess(i,j)))*5140.66
         enddo
      enddo

      ! Close file
      close(unit)

      return
    end subroutine simtrans

!##################################################################

    subroutine wrout(pvec,maxdim,ncoo,peig,iimag,xcoo,aatm,ain,&
         qirrep)

      implicit none
      
      integer*8                           :: maxdim,ncoo,i,j,k,unit
      integer*8, dimension(maxdim)        :: iimag
      real*8, dimension(maxdim,maxdim)    :: pvec
      real*8, dimension(maxdim)           :: peig,xcoo
      character(len=2), dimension(maxdim) :: aatm
      character(len=80)                   :: ain,atmp
      character(len=6), dimension(maxdim) :: qirrep

      unit=20

!------------------------------------------------------------------
! Sort the eigenvectors by energy
!------------------------------------------------------------------
      call sortvecs(pvec,peig,iimag,maxdim,ncoo)

!------------------------------------------------------------------
! Output all eigenvectors of the projected Hessian to a single xyz
! file for inspection
!------------------------------------------------------------------
      open(unit,file='eigvec.xyz',form='formatted',status='unknown')
      do i=1,ncoo
         atmp=''
         if (i.lt.10) then
            write(atmp,'(a1,i1,2x,a)') 'Q',i,&
                 qirrep(i)(1:len_trim(qirrep(i)))
         else
            write(atmp,'(a1,i2,2x,a)') 'Q',i,&
                 qirrep(i)(1:len_trim(qirrep(i)))
         endif
         write(unit,'(i2)') ncoo/3
         if (iimag(i).eq.1) then
            write(unit,'(a8,2x,F13.7,2(x,a))') &
                 atmp,sqrt(peig(i))*5140.66,'I','cm-1'
         else
            write(unit,'(a8,2x,F13.7,x,a)') &
                 atmp,sqrt(peig(i))*5140.66,'cm-1'
         endif
         do j=1,ncoo/3
            write(unit,'(a2,2x,6(F10.7,2x))') aatm(j),xcoo(j*3-2),&
                 xcoo(j*3-1),xcoo(j*3),pvec(j*3-2,i)/sqrt(mass(j)),&
                 pvec(j*3-1,i)/sqrt(mass(j)),pvec(j*3,i)/sqrt(mass(j))
         enddo
      enddo
      close(unit)

!------------------------------------------------------------------
! Output info to the data file
!------------------------------------------------------------------
      atmp=''
      k=index(ain,'.')
      write(atmp(1:k-1),'(a)') ain(1:k-1)
      write(atmp(k:k+3),'(a)') '.dat'
      open(unit,file=atmp,form='unformatted',status='unknown')

! System size
      write(unit) ncoo

! Cartesian coordinates in the Eckart frame
      do i=1,ncoo
         write(unit) xcoo(i)
      enddo

! Masses
      do i=1,ncoo/3
         do j=1,3
            write(unit) mass(i)
         enddo
      enddo

! Projected eigenvectors
      do i=1,ncoo
         do j=1,ncoo
            write(unit) pvec(i,j)
         enddo
      enddo

! Projected eigenvalues
      do i=1,ncoo
         write(unit) peig(i)
      enddo

! Imaginary frequency information
      do i=1,ncoo
         write(unit) iimag(i)
      enddo
      close(unit)

      return
    end subroutine wrout

!##################################################################

    subroutine sortvecs(pvec,peig,iimag,maxdim,ncoo)

      implicit none
      
      integer*8                        :: maxdim,ncoo,i,j,k,iswap
      integer*8, dimension(maxdim)     :: iimag
      real*8, dimension(maxdim,maxdim) :: pvec,tmp2
      real*8, dimension(maxdim)        :: peig,tmp1
      real*8                           :: swap

      do i=1,ncoo-1
         do j=i+1,ncoo
            if (peig(i).gt.peig(j)) then
               swap=peig(i)
               peig(i)=peig(j)
               peig(j)=swap
               iswap=iimag(i)
               iimag(i)=iimag(j)
               iimag(j)=iswap
               do k=1,ncoo
                  swap=pvec(k,i)
                  pvec(k,i)=pvec(k,j)
                  pvec(k,j)=swap
               enddo
            endif
         enddo
      enddo

      return
    end subroutine sortvecs

!##################################################################

  end program projection
